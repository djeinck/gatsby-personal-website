---
title: "What They Look For"
cover: "fang.jpg"
date: "2019-06-15"
category: "tech interview"
tags:
    - topics
---


What they are looking for
- Does the candidate listen carefully and comprehend the question? 
- Are the correct questions asked before proceeding? (important!)
- Is brute force used to solve a problem? (not good!)
- Are things assumed without first checking? (not good!)
- Are hints heard and needed?
- Is the candidate slow to comprehend / solve problems? (not good!)
- Does the candidate enjoy finding multiple solutions before choosing the best one? 
- Are new ideas and methods of tackling a problem sought? 
- Is the candidate inventive and flexible in their solutions and open to new ideas?
- can questioning move up to more complex problem solving?
- Talk through your thought process about the questions you are asked.  In all of Google's interviews, our engineers are evaluating not only your technical abilities but also how you approach problems and how you try to solve them. 
- Ask clarifying questions if you don't understand the problem or need more information.  Many of the questions asked in Google interviews are deliberately underspecified because our engineers are looking to see how you engage the problem.  In particular, they are looking to see which areas leap to your mind as the most important piece of the technological puzzle you've been presented.  
- Think about ways to improve the solution you'll present.  In many cases, the first answer that springs to mind may not be the most elegant solution and may need some refining.  It's definitely worthwhile to talk through your initial thoughts to a question and take time to compose a more efficient solution. 


Algorithms - Approach the problem with both bottom-up and top-down algorithms. You will
be expected to know the complexity of an algorithm and how you can improve/change it.
Algorithms that are used to solve Google problems include sorting (plus searching and binary
search),  d-conquer, dynamic programming/memoization, greediness, recursion or
algorithms linked to a specific data structure. Know Big-O notations (e.g. run time) and be
ready to discuss complex algorithms like Dijkstra and A*. We recommend discussing or
outlining the algorithm you have in mind before writing code.

Sorting - Be familiar with common sorting functions and on what kind of input data they’re
efficient on or not. Think about efficiency means in terms of runtime and space used. For
example, in exceptional cases insertion-sort or radix-sort are much better than the generic
QuickSort/MergeSort/HeapSort answers.

Data structures - You should study up on as many data structures as possible. Data
structures most frequently used are arrays, linked lists, stacks, queues, hash-sets, hash-maps,
hash-tables, dictionary, trees and binary trees, heaps and graphs. You should know the data
structure inside out, and what algorithms tend to go along with each data structure.

Mathematics - Some interviewers ask basic discrete math questions. This is more prevalent
at Google than at other companies because counting problems, probability problems and
other Discrete Math 101 situations surround us. Spend some time before the interview
refreshing your memory on (or teaching yourself) the essentials of elementary probability
theory and combinatorics. You should be familiar with n-choose-k problems and their ilk.

Graphs - Consider if a problem can be applied with graph algorithms like distance, search,
connectivity, cycle-detection, etc. There are three basic ways to represent a graph in memory
(objects and pointers, matrix, and adjacency list) — familiarize yourself with each
representation and its pros and cons. You should know the basic graph traversal algorithms,
breadth-first search and depth-first search. Know their computational complexity, their
tradeoffs and how to implement them in real code.

Recursion - Many coding problems involve thinking recursively and potentially coding a
recursive solution. Use recursion to find more elegant solutions to problems that can be
solved iteratively.
